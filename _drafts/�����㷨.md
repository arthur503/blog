---
layout: default
title: Java基础：排序算法总结
---
笔试被笔了好多次，所以总结一下。包括：

* 哪些排序算法与初始顺序无关；
* 排序算法的时间复杂度和空间复杂度，包括最优、最差、平均；
* 排序算法的原理；
* 稳定性；
* 代码实现；








归并排序效率O（nlogn），归并的最佳、平均和最糟用例效率之间没有差异。 

快速排序平均效率O（nlogn），适用于排序大列表。 此算法的总时间取决于枢纽值的位置；选择第一个元素作为枢纽，可能导致O（n²）的最糟用例效率。若数基本有序，效率反而最差。选项中间值作为枢纽，效率是O（nlogn）。 

堆排序的最坏时间复杂度为O(nlgn)。堆排序的平均性能较接近于最坏性能。     由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。     堆排序是就地排序，辅助空间为O(1)，     它是不稳定的排序方法。 

基数排序又被称为桶排序。基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的比较性排序法。















百度百科上[排序算法](http://baike.baidu.com/link?url=e-5QTtb_2iVT3m5ucfORtxrWc7HP2N3NHgHrEkxNoVemLeGdHFGklIWeHwoC0wu8)的介绍中，有对排序算法的一个总结：

> 在计算机科学所使用的排序算法通常被分类为：
> (a)计算的复杂度（最差、平均、和最好性能），依据列表(list)的大小(n)。
> 一般而言，好的性能是O\left(n\log_2n\right)，且坏的性能是O\left(n^2\right)。对于一个排序理想的性能是O\left(n\right)。
> 而仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要O\left(n\log_2n\right)。
> (b)存储器使用量（空间复杂度）（以及其他电脑资源的使用）
> (c)稳定度：稳定的排序算法会依照相等的关键（换言之就是值）维持纪录的相对次序。
> (d)一般的方法：插入、交换、选择、合并等等。交换排序包含冒泡排序和快速排序。插入排序包含希尔排序，选择排序包括堆排序等。

还有一个算法列表：【最后总结完了删掉！】

> 简介
> 
> 在这个表格中，n是要被排序的纪录数量以及k是不同键值的数量。
> 稳定的
> 
> 冒泡排序（bubble sort） — O(n^2）
> 鸡尾酒排序(Cocktail sort，双向的冒泡排序) — O(n^2）
> 插入排序（insertion sort）— O(n^2)
> 桶排序（bucket sort）— O(n); 需要 O(k) 额外空间
> 计数排序(counting sort) — O(n+k); 需要 O(n+k) 额外空间
> 合并排序（merge sort）— O(nlog n); 需要 O(n) 额外空间
> 原地合并排序— O(n^2)
> 二叉排序树排序 （Binary tree sort） — O(nlog n)期望时间； O(n^2)最坏时间； 需要 O(n) 额外空间
> 鸽巢排序(Pigeonhole sort) — O(n+k); 需要 O(k) 额外空间
> 基数排序（radix sort）— O(n·k); 需要 O(n) 额外空间
> Gnome 排序— O(n^2)
> 图书馆排序— O(nlog n) with high probability，需要 （1+ε)n额外空间
> 不稳定的
> 
> 选择排序（selection sort）— O(n^2)
> 希尔排序（shell sort）— O(nlog n) 如果使用最佳的现在版本
> 组合排序— O(nlog n)
> 堆排序（heapsort）— O(nlog n)
> 平滑排序— O(nlog n)
> 快速排序（quicksort）— O(nlog n) 期望时间，O(n^2) 最坏情况； 对于大的、乱数列表一般相信是最快的已知排序
> Introsort— O(nlog n)
Patience sorting— O(nlog n+ k) 最坏情况时间，需要 额外的 O(n+ k) 空间，也需要找到最长的递增子串行（longest increasing > subsequence）
> 不实用的排序算法
> 
> Bogo排序— O(n× n!) 期望时间，无穷的最坏情况。
> Stupid sort— O(n^3); 递归版本需要 O(n^2) 额外存储器
> 珠排序（Bead sort） — O(n) or O（√n)，但需要特别的硬件
> Pancake sorting— O(n)，但需要特别的硬件
> stooge sort——O（n^2.7）很漂亮但是很耗时

先介绍一下“稳定性”的概念：

> 一个排序算法是稳定的，就是当有两个相等记录的关键字R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。

下面逐一对排序算法进行分析。每个算法包括：原理、稳定性、复杂度分析（包括时间复杂度和空间复杂度）。还有与初始顺序是否相关。

注：所有的排序算法都是以进行升序排序为例。

一、插入排序（insertion sort）

1. 原理

插入排序的原理是先建立一个空列表，用来保存排序后的有序数列。每次从原数列取一个数，将其“插入”到新的“有序列表”中，使新列表保持有序状态。重复，直至原数列为空。

插入排序的思想很直观、简单，容易实现。它占用了额外的空间来保存有序数列，对每个数字都进行插入判断，时间复杂度是平方级的，效率不高。

2. 稳定性

插入排序是稳定的。排序后的数列中，数值相同的关键字排序后顺序保持不变。

3. 复杂度分析

插入排序与初始顺序有关。若要建立升序排列，则初始顺序为降序排列时速度最快（每次都在第一次比较后插入），为O(n)；初始顺序也为升序排列时速度最慢（每次均要比较到队列末尾），为O(n^2)。因此，插入排序的时间复杂度最优为O(n)，最差为O(n^2)，平均为O(n^2)。【平均的对吗？】

插入排序需要建立一个新的数列，大小与原数列相同，因此，空间复杂度是O(n)。

* 实现难度

容易。


二、冒泡排序

原理

冒泡排序是对相邻元素的比较。每一次比较，若后者较大则不变，否则二者交换。这样，经过n-1轮的比较，每一轮都将数列中最大的值放到最后（每一轮的比较次数也逐次递减），最终完成升序排列。

稳定性

冒泡排序是稳定的，排序结果与初始顺序有关。


冒泡排序的排序时间与初始顺序无关，由于每一轮的比较次数是固定的，因此，最终的排序时间复杂度是固定的O(n^2)。

冒泡排序只有进行数据交换位置时需要额外空间（如果对空间要求严格，数据交换也可以不需要额外空间，进行两次异或比较即可实现交换），空间复杂度是O(1)。

三、选择排序

原理

选择排序也是对数组进行遍历，对每一次遍历（如第i次），都寻找当前所有元素中最小的元素，与第i位元素进行交换；再进行下一次遍历，直至所有元素排序完成。

稳定性

选择排序是稳定的，排序结果与初始顺序有关。

选择排序的排序时间和初始顺序是无关的，每一次遍历都需要和所有的元素进行对比，因此，时间复杂度是固定的O(n^2)。

选择排序不需要额外空间存放数列，因此空间复杂度是O(1)。

难度

容易。

四、快速排序

> 现在开始，我们要接触高效排序算法了。实践证明，快速排序是所有排序算法中最高效的一种。它采用了分治的思想：先保证列表的前半部分都小于后半部分，然后分别对前半部分和后半部分排序，这样整个列表就有序了。这是一种先进的思想，也是它高效的原因。因为在排序算法中，算法的高效与否与列表中数字间的比较次数有直接的关系，而"保证列表的前半部分都小于后半部分"就使得前半部分的任何一个数从此以后都不再跟后半部分的数进行比较了，大大减少了数字间不必要的比较。但查找数据得另当别论了。

【百度百科上有快排的动态图，下载下来】

快排采用了分治的思想（可以利用递归的方法实现）：首先保证列表的前半部分都小于后半部分，然后对前半部分和后半部分均进行排序（同样采用快排）。

快排是所有排序算法中最高效的一种，它的高效原因是：“保证列表的前半部分都小于后半部分”后，前半部分的任何一个数都不必要再跟后半部分的数进行比较了，可以大大减少数字之间的不必要的比较次数。

那么，快排的思路这么简单，在具体实现上，就要考虑如何保证列表的前半部分都小于后半部分？

我之前看原理的时候以为快排是可以保证前半部分和后半部分是可以保证元素数量相同的（即：原数列均匀分为两部分），因为在看动态图的时候直观感受就是这样。于是我选取a,b,c,d,e,f六个数字，依照原理选择第一个元素a作为初始元素的key，假设每次元素比较均会导致变化，并且新元素会替换前一个key作为新key（注意：这一点是错误的）。最终排完之后，可以得到一个排序结果和中间过程中的不等式组。但是，计算后发现，根据不等式组是无法推出最后的排序结果中前半部分均大于后半部分的，只能推出前半部分的某些元素大于后半部分的某些元素，但并不完全。

这里面的错误有两点：1. 快排是无法保证每次排序后前后半部分元素数量是相同的。动态图中只是显示的那样而已。2. key的选择在一轮排序结束之前是不变的。我之前一直以为，要保证前后半部分元素相同个，则key肯定不能是不变的（否则一般情况下前后半部分元素不同）。但既然不要求保证前后半元素数量相同，那么key选择确定之后不改变，则在本轮结束后，就可以将所有元素分为大于key和小于key的两部分。但是，这里有个问题就是：key的选择很重要。最好的key是可以将元素分为数量相似的两部分（近似二分），这样才能性能达到最好。但是，在实际中，经常选择第一位的值作为key。这有一定的随机性，在实际效果中也比较好。

五、堆排序

堆排序与前面的算法都不同，它是这样的：

首先新建一个空列表，作用与插入排序中的"有序列表"相同。

找到数列中最大的数字，将其加在"有序列表"的末尾，并将其从原数列中删除。

重复2号步骤，直至原数列为空。

堆排序的平均时间复杂度为nlogn，效率高（因为有堆这种数据结构以及它奇妙的特征，使得"找到数列中最大的数字"这样的操作只需要O（1）的时间复杂度，维护需要logn的时间复杂度），但是实现相对复杂（可以说是这里7种算法中比较难实现的）。

看起来似乎堆排序与插入排序有些相像，但他们其实是本质不同的算法。至少，他们的时间复杂度差了一个数量级，一个是平方级的，一个是对数级的。

特点

堆排序（HeapSort）是一树形选择排序。堆排序的特点是：在排序过程中，将R[l..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系（参见二叉树的顺序存储结构），在当前无序区中选择关键字最大（或最小）的记录

区别

直接选择排序中，为了从R[1..n]中选出关键字最小的记录，必须进行n-1次比较，然后在R[2..n]中选出关键字最小的记录，又需要做n-2次比较。事实上，后面的n-2次比较中，有许多比较可能在前面的n-1次比较中已经做过，但由于前一趟排序时未保留这些比较结果，所以后一趟排序时又重复执行了这些比较操作。

堆排序可通过树形结构保存部分比较结果，可减少比较次数。

【存疑：堆排序是如何调整堆的？每次都需要调整堆，那时间复杂度会增加吗？】

六、归并排序

归并操作(merge)，也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。


七、希尔排序

原理：又称增量缩小排序。先将序列按增量划分为元素个数相同的若干组，使用直接插入排序法进行排序，然后不断缩小增量直至为1，最后使用直接插入排序完成排序。
要点：增量的选择以及排序最终以1为增量进行排序结束。

八、基数排序

基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。

九、桶排序

桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。

桶排序以下列程序进行：
设置一个定量的数组当作空桶子。
寻访串行，并且把项目一个一个放到对应的桶子去。
对每个不是空的桶子进行排序。
从不是空的桶子里把项目再放回原来的串行中。








