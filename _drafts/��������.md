---
layout: default
title: Java基础：数据容器分析之Stack和Queue
---
首先来看自己提出的问题：
1. Queue和Stack在Java中的实现；
2. List、Set和Map在Java中的实现；
3. HashMap、HashSet、HashTable等源码分析；
4. HashMap、HashSet、HashTable等对并发的支持；
5. 能否自己构建一个简单的Stack、Queue、Set和Map，只实现基本功能即可；



我觉得《Java编程思想》中，CH11持有对象这一章写的很乱，看的时候总觉得思路各种飞散，所以我决定把这部分重新缕一缕，重新梳理一下各个接口和实现之间的关系。





在编程语言中，如果不是函数式编程语言，那么就需要使用变量存储对象。

如何存储？Java中提供了基础类型变量，还可以自己设计引用类型变量来存储。如果只需要存储一个对象，只需要设定一个变量即可。如果需要存储多个变量，问题就来了。

存储多个变量分两种：1. 存储固定数目的多个变量；2. 存储不确定数目（只有运行时才知道数目甚至类型）的多个变量；

对于第一种情况，我们可以使用数组，可以很方便的保存和获取数据。但对于更一般的后一种情况，在写程序时不知道将来需要多少对象，或者是否需要更复杂的方式来存储对象，那么，数组尺寸固定这一限制就过于受限了。因此，我们需要更完善的数据容器，来容纳不确定的元素对象。

Java类库提供了一套完整的容器类，包括List、Set、Queue和Map，这些对象称为“集合类”，还包括Collection。我们把这些都称作数据容器。Java容器类都可以自动地调整自己的尺寸，因此，编程时无需担心容器容量需要设置多大。

容器的好处？【不需要关心设置多大和支持泛型？？】

不同的容器有不同的特性，我们先简要说明，之后再一一分析。

* Set：对每个值只保存一个对象；
* Map：允许保存某些对象与其他对象关联起来的关联数组；
【未完成！！】

11.1 泛型和类型安全的容器

主要内容：
1. 容器可以使用预定义的泛型，使用尖括号括起类型参数（可以多个），使得在编译期就防止将错误类型放入容器，这样不用顾虑类型转换问题。
2. 在指定了某个类型作为泛型参数后，并不仅限于确切类型的对象，还可以使用向上转型。
2. 泛型远不止类型安全的容器这么简单，详见CH15。

11.2 基本概念

容器的用途在于“保存对象”，据此将容器类划分为两个不同的概念：

1. 	Collection。一个独立元素的队列，这些元素都服从一条或多条规则。
	List必须按照添加的顺序保存元素；Set不能有重复元素；Queue按照排队规则确定对象产生的顺序（通常与他们被插入的顺序相同）（只允许在容器的一“端”插入对象，并从另外一“端”移除对象）。
2. 	Map。一组成对的“键值对”对象，允许使用键来查找值。
	ArrayList允许使用数字来查找值，因此在某种意义上来讲，它将数字与对象关联在了一起；映射表允许使用另一个对象来查找某个对象，因此也被成为“关联数组”，或者被称为“字典”。

另外，所有的Collection类都可以使用foreach语法遍历，当然，后面还会讲到的迭代器更加灵活。

11.3 添加一组元素

可以使用Collection.addAll(), Collections.addAll()(注意与前者不同), Arrays.asList()等方法添加一组元素。略。

11.4 容器的打印

书中通过容器对元素的打印顺序，总结了一下各容器的特点。

ArrayList和LinkedList都是List类型，都按照被插入的顺序保存元素。两者不同之处在于执行某些类型的操作时的性能，而且LinkedList包含的操作也更多。

HashSet、TreeSet和LinkedHashSet都是Set类型，输出显示在Set中。HashSet使用哈希方法寻址，获取元素速度最快；如果在Set中看重存储顺序，可以使用TreeSet，按照比较结果的升序保存对象【存疑：什么的比较结果？】；LinkedHashList是按照被添加的顺序保存对象。

HashMap使用哈希方法寻址，查找速度最快；TreeMap按照比较结果的升序排序【存疑：同上，比较什么的结果？】；LinkedHashMap按照插入顺序保存键，同时还保留了HashMap的查询速度【存疑：LinkedHashMap是使用链表存储的？怎么使用哈希方法寻址？】。

11.5 List

吐槽一句，终于进入正题了，开始分析各个容器了。

List接口继承自Collection接口。它承诺可以将元素为维护在特定的序列中。List接口在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素。

有两种基本类型的List：
1. 基本的ArrayList：擅长随机访问元素，但插入和移除元素较慢；
2. LinkedList：插入和删除操作代价较低，提供了优化的顺序访问，它的特性集较ArrayList更大。但是LinkedList的随机访问速度相对较慢。

剩下的就是讲了一下List中的一些方法，如add(), remove(), subList(), addAll(), containAll(), retainAll(), removeAll(),set()(作者认为使用replace()作为名字更靠谱), isEmpty(), clear()等方法。

11.6 迭代器

迭代器是一个对象，它的工作在于遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构。

迭代器是轻量级对象：创建它的代价小。它有使用限制：

1. 只能单向移动；
2. 使用next()方法获取下一个元素；使用hasNext()方法检查序列中是否还有元素；使用remove()方法将迭代器新近返回的元素删除。

迭代器的真正作用在于：能够将遍历序列的操作与序列底层的结构分离。正由于此，我们可以说，迭代器统一了对容器的访问方式。我们可以在获得迭代器后，直接对迭代器的获取的元素操作，而不用关心迭代器内的元素类型信息到底是什么。从这个角度来看，迭代器非常强大。

ListIterator是一个更加强大的Iterator子类型，它只能用于各种List类的访问，不过功能更加强大。增加的功能包括：

1. 可以双向移动而非单向移动；
2. 可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引；
3. 可以使用set()方法替换它访问过的最后一个元素；
4. 可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。

11.7 LinkedList

LinkedList和ArrayList一样实现了基本的List接口，它在执行某些操作（插入和移除）时比ArrayList更高效，但在随即访问操作方面要逊色。







