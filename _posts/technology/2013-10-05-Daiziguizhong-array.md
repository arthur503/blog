---
layout: default
title: 待字闺中：数组类题目之统计数字出现次数【存疑】
---
看@陈利人 老师的微信号“待字闺中”，有一段时间连续好几道数组题，把数组的各个思考方向都涵盖到了，所以萌生出总结一下的念头。主要是看看数组类题目的解题思路有哪些方向，分别适用于哪些场景。题目会一道道分析，慢慢添加的。

先来看看0911的题目：找数字续。题目如下：

> 一个数组A，数字出现的情况，只有以下三种：一些数字只出现一次；一些数字出现两次；只有一个数字出现三次。请给出方法，找到出现三次的数字。关注微信公众账号“待字闺中”，了解更多。

根据“先实现，后优化”的原则，我们先把最简单明显的思路列出来，之后再往下延伸，谈优化和最佳方案。

我想到的解决方法如下：

	/**
	 * 法一：使用HashMap存储，之后遍历元素找到count为3的数字。
	 * 
	 * 优点：万金油方法，适用范围广，可以用来找count为任意值的数字。
	 * 		若需要查找操作，时间复杂度O(1)。
	 * 缺点：需要占用额外空间。
	 * 复杂度：空间复杂度O(n)，时间复杂度O(n)。
	 */
	
	/**
	 * 法二：使用2位的bitmap存储，之后遍历找到count为3的数字。
	 * 由于最多出现3次，所以2位bit即可表示。
	 * 
	 * 优点：占用空间少，同样可以用来找count为任意值的数字。
	 * 		若需要查找操作，时间复杂度O(1)。
	 * 		另外，对题目而言此方法只需在建立过程中，若判断count==3，即为结果。
	 * 缺点：需要使用额外空间。
	 * 复杂度：空间复杂度O(n)，时间复杂度O(n)。
	 */
	
	/**
	 * 法三：使用本数组自身存储（元素*N），根据元素哈希值计算应该存储的位置。
	 * 若发生冲突则往后顺延（到末尾则移至开头），之后遍历找到count为3的数字。
	 * 
	 * 优点：不适用额外空间，可以用来找count为任意值的数字。
	 * 缺点：时间复杂度虽然同为O(n)，但遍历次数更多。
	 * 复杂度：空间复杂度O(1)，时间复杂度为O(n)。
	 * 问题：如何判断存储位置的值与本身相同（冲突情况下）？
	 */
		
但是，法三中的问题一直没想到如何解决。实际上就是：如何把数组中的数字映射到一个确定的位置（不发生冲突或发生冲突后依然可以辨认出原来的数字）。在这种方法中，如果是数组中数字为1~n，就很好解决，直接使用k-1作为数组下标即可。但是，如果数字的范围不确定，就无法将数字与位置一一映射。此时，不管数字重不重复，我们好像都无法解决数据映射位置冲突的情况。【存疑：无法解决吗？】

看了“待字闺中”微信号的解答，发现还遗漏了好多思路。最简单的如排序后统计，就没有往这方面去想。。

	/**
	 * 法四：快速排序，之后寻找连续为3的数字。
	 * 复杂度：时间复杂度O(nlog(n))。
	 */

另外，还有的同学思路是：

	/**
	 * 法五：取得A中所有元素的乘积p（假设p没有溢出），遍历数组查看p%(A<sub>i</sub>^3)
	 * 是否为0；若为0，则遍历数组查看A<sub>i</sub>出现次数是否为3.
	 * 复杂度：时间复杂度O(n^2)。
	 */

陈立人老师在微信号里只是给了这几个思路，并没有给出解答，而是留了一个思考题目：上面这个题目能否在时间复杂度O(n)，空间复杂度O(1)的条件下完成？如果不能怎么说明？

我想了下，能够想到的时间复杂度O(n)，空间复杂度O(1)的方法只有之前提到的法三，但是如何映射的问题还是没有解决。【存疑：如何解决，或者有其他的方法吗？】

查看了微博上的留言，有人的方法如下：

> 宝宝的贝贝先生：继续开一个大小32的数组，求二进制数位和，模3得到出现1,2次的数位和，模2得到出现1,3次的数位和，所有的数位和减去模2的得到出现2次的数位和，再类似折腾下就出来了... (9月11日 14:16)

但有人认为行不通：

> Li-D-SM：回复@宝宝的贝贝先生:感觉行不通，只看最低位，1的个数若为5.(1,1,1,3,5)(1,1,3,3,5,6,6,6).对于同样的5而言，1,6在最低位的数显然是不同的，无法得到出现三次的数字最低位是1还是0 (9月12日 13:22)

唔，我还没看懂。【存疑】

下面对在数组中，统计数字出现次数的题目进行总结：

1. 万金油解法HashMap统计；
2. 对数字进行统计若重复不多（如1、2次等）时，可以考虑bitmap；
3. 数组排序后统计；
4. 所有元素乘积对某元素的n次方取余，之后再判断是否确定（适用于元素为质数的情况，就无需再次确定，时间复杂度可以由O(n^2)变为O(n)）；
5. 使用本数组\*N存储，哈希寻找存储位置？【存疑：问题未解决】
6. 二进制数位和方法？【存疑】

另外，若是要我来选的话，2位的bitmap方法不错，虽然需要额外的空间，但实际中比HashMap需要的空间最优1/32（HashMap中需要存储key和value，至少两个int），实际表现应该不错。而且可扩展性强，可以持续添加新的数字（排序就不行，每次需要重排）；查找操作快，对于其他数字的查找count操作的时间复杂度为O(1)（排序的查找操作为O(n))。另外，bitmap方法对题目而言无需完全建立，只需在建立过程中，若判断count==3，即为结果。整体表现还是不错的。

下面再来看一道0907的题目：找数字（其实是上一道题的前一道题目），如下：

> 数组A中，除了某一个数字x之外，其他数字都出现了三次，而x出现了一次。请给出最快的方法，找到x。

同样的，我们可以看到，前面所提到的：万金油HashMap、2位Bitmap、排序后统计、所有元素相乘后相除再判断的方法都可以实现，但是都不够快。题目中要找到最快的方法。

一般程序执行，最快的就是位操作了。我们想到了异或。但是会发现，如果其他数字都出现了2次（或偶数次），而x出现1次（或奇数次），用异或可以。但题目中其他数字也是出现了奇数次，因此，异或就失效了。

那是不是就不能应用位操作了呢？不是的。

> 题目中，如果数组中的元素都是三个三个出现的，那么从二进制表示的角度，每个位上的1加起来，应该可以整除3。
> 
> 如果某个特定位上的1加起来，不可以被3整除，说明对应x的那位是1。若可以被3整除，则为0。

根据这一思想，我们可以开辟一个大小为32的int数组B，其中在int B<sub>i</sub>中，保存A中所有元素的二进制表示中第i位的和。这样，最后，我们把得到的数组都对3取余，得到的就是x的各个位，转化为十进制即可。

【思考】其实我们想一下，使用异或来进行位运算的时候，也是相当于把对应位出现的次数进行保存了。不过异或是通过把两个1消去为0来保存，使得只出现1次的1显露出来。因此，异或的限制在于只能保存/消去偶数个位的值。而使用int数组来保存对应位的出现次数，相当于对此进行了扩展，通过使用额外空间来获得更多信息的保存结果。

我们可以看到，这个思路很巧妙。通过开辟一个长度32的数组，即可把数组中对应位上出现1的次数进行统计了。占用空间不大，但是效率很高。另外，这个方法限制也少。

1. 这个方法不限制特殊数字x出现的次数是否为1，也就是说，加入其它数字都出现k次，那么只要x出现次数不为k即可（注意：若x出现次数大于k，也不影响最终对位的判断，只是最终某一位的统计结果取余后与x出现次数相差k的整数倍）。
2. 如果在数组中，只有一个数字是特殊的，那么一定要利用其它数字的特性，可以通过异或、对应位相加（使用int保存每个位相加的结果）等方法，来把这个一个特性区别出来。

不过，最后，陈利人老师还给留了一个思考题：这里申请了一个数组的空间，如果这个是不被允许的呢？【存疑：该如何呢？】
